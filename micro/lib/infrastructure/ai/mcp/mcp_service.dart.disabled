import 'package:riverpod/riverpod.dart';
import 'package:flutter/material.dart';
import 'mcp_client_adapter.dart';
import 'mcp_ai_provider.dart';
import 'mcp_server_discovery.dart';

/// Main service that coordinates MCP functionality
class MCPService {
  static const _tag = 'MCPService';
  
  final Ref ref;
  final MCPServerDiscovery _discovery = MCPServerDiscovery();
  McpAIProvider? _aiProvider;
  MCPClientAdapter? _adapter;
  
  MCPService(this.ref);
  
  /// Initialize MCP service
  Future<void> initialize() async {
    try {
      // Initialize server discovery
      await _discovery.initialize();
      
      // Get discovered servers
      final servers = _discovery.getDiscoveredServers();
      
      // Create MCP adapter config
      final config = MCPClientConfig(
        clientName: 'micro-assistant',
        clientVersion: '1.0.0',
        servers: servers,
      );
      
      // Initialize adapter
      _adapter = MCPClientAdapter();
      await _adapter!.initialize(config);
      
      // Initialize AI provider
      _aiProvider = McpAIProvider(ref);
      await _aiProvider!.initialize(config);
      
      print('$_tag: MCP service initialized with ${servers.length} servers');
    } catch (e) {
      print('$_tag: Failed to initialize: $e');
      rethrow;
    }
  }
  
  /// Get AI provider
  McpAIProvider? get aiProvider => _aiProvider;
  
  /// Get client adapter
  MCPClientAdapter? get adapter => _adapter;
  
  /// Get server discovery
  MCPServerDiscovery get discovery => _discovery;
  
  /// Add new MCP server
  Future<void> addServer(MCPServerConfig server) async {
    await _discovery.addServer(server);
    _adapter?.addServer(server);
    print('$_tag: Added server: ${server.name}');
  }
  
  /// Remove MCP server
  Future<void> removeServer(String serverId) async {
    await _discovery.removeServer(serverId);
    _adapter?.removeServer(serverId);
    print('$_tag: Removed server: $serverId');
  }
  
  /// Test server connection
  Future<bool> testServer(String serverId) async {
    final server = _discovery.getServer(serverId);
    if (server == null) {
      return false;
    }
    
    return await _discovery.testServer(server);
  }
  
  /// Refresh server discovery
  Future<void> refreshServers() async {
    await _discovery.refresh();
    final servers = _discovery.getDiscoveredServers();
    
    // Update adapter with new servers
    for (final server in servers) {
      _adapter?.addServer(server);
    }
    
    print('$_tag: Refreshed servers, found ${servers.length} servers');
  }
  
  /// Get server status
  Map<String, dynamic> getServerStatus(String serverId) {
    final server = _discovery.getServer(serverId);
    if (server == null) {
      return {'status': 'not_found'};
    }
    
    final isActive = _adapter?.getActiveServerIds().contains(serverId) ?? false;
    
    return {
      'status': isActive ? 'active' : 'configured',
      'name': server.name,
      'transport': server.transportType.name,
      'url': server.url,
      'autoConnect': server.autoConnect,
    };
  }
  
  /// Get all servers with status
  List<Map<String, dynamic>> getAllServerStatus() {
    final servers = _discovery.getDiscoveredServers();
    final activeIds = _adapter?.getActiveServerIds() ?? [];
    
    return servers.map((server) {
      return {
        'id': server.id,
        'name': server.name,
        'status': activeIds.contains(server.id) ? 'active' : 'configured',
        'transport': server.transportType.name,
        'autoConnect': server.autoConnect,
      };
    }).toList();
  }
  
  /// Shutdown service
  Future<void> shutdown() async {
    await _aiProvider?.shutdown();
    await _adapter?.shutdown();
    print('$_tag: MCP service shutdown complete');
  }
}

/// Provider for MCP service
final mcpServiceProvider = FutureProvider<MCPService>((ref) async {
  final service = MCPService(ref);
  await service.initialize();
  return service;
});

/// State notifier for MCP server list
class MCPServerListNotifier extends StateNotifier<AsyncValue<List<MCPServerConfig>>> {
  final Ref ref;
  
  MCPServerListNotifier(this.ref) : super(const AsyncValue.loading());
  
  /// Load servers
  Future<void> loadServers() async {
    state = const AsyncValue.loading();
    
    try {
      final mcpService = await ref.read(mcpServiceProvider.future);
      final servers = mcpService.discovery.getDiscoveredServers();
      state = AsyncValue.data(servers);
    } catch (e, stack) {
      state = AsyncValue.error(e, stack);
    }
  }
  
  /// Add server
  Future<void> addServer(MCPServerConfig server) async {
    state = const AsyncValue.loading();
    
    try {
      final mcpService = await ref.read(mcpServiceProvider.future);
      await mcpService.addServer(server);
      
      final servers = mcpService.discovery.getDiscoveredServers();
      state = AsyncValue.data(servers);
    } catch (e, stack) {
      state = AsyncValue.error(e, stack);
    }
  }
  
  /// Remove server
  Future<void> removeServer(String serverId) async {
    state = const AsyncValue.loading();
    
    try {
      final mcpService = await ref.read(mcpServiceProvider.future);
      await mcpService.removeServer(serverId);
      
      final servers = mcpService.discovery.getDiscoveredServers();
      state = AsyncValue.data(servers);
    } catch (e, stack) {
      state = AsyncValue.error(e, stack);
    }
  }
  
  /// Refresh servers
  Future<void> refreshServers() async {
    state = const AsyncValue.loading();
    
    try {
      final mcpService = await ref.read(mcpServiceProvider.future);
      await mcpService.refreshServers();
      
      final servers = mcpService.discovery.getDiscoveredServers();
      state = AsyncValue.data(servers);
    } catch (e, stack) {
      state = AsyncValue.error(e, stack);
    }
  }
  
  /// Test server connection
  Future<bool> testServer(String serverId) async {
    try {
      final mcpService = await ref.read(mcpServiceProvider.future);
      return await mcpService.testServer(serverId);
    } catch (e) {
      return false;
    }
  }
}

/// Provider for MCP server list
final mcpServerListProvider = StateNotifierProvider<MCPServerListNotifier, AsyncValue<List<MCPServerConfig>>>(
  (ref) => MCPServerListNotifier(ref),
);

/// Provider for active MCP connections
final mcpActiveConnectionsProvider = StreamProvider<List<String>>((ref) async* {
  final mcpService = await ref.read(mcpServiceProvider.future);
  
  while (true) {
    final connections = mcpService.adapter?.getActiveServerIds() ?? [];
    yield connections;
    await Future.delayed(const Duration(seconds: 2));
  }
});

/// UI widget for MCP server management
class MCPServerManagementWidget extends ConsumerWidget {
  const MCPServerManagementWidget({super.key});
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final serversAsync = ref.watch(mcpServerListProvider);
    final connectionsAsync = ref.watch(mcpActiveConnectionsProvider);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('MCP Server Management'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () async {
              await ref.read(mcpServerListProvider.notifier).refreshServers();
            },
          ),
          IconButton(
            icon: const Icon(Icons.add),
            onPressed: () async {
              await _showAddServerDialog(context, ref);
            },
          ),
        ],
      ),
      body: serversAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text('Error: $error'),
              ElevatedButton(
                onPressed: () async {
                  await ref.read(mcpServerListProvider.notifier).loadServers();
                },
                child: const Text('Retry'),
              ),
            ],
          ),
        ),
        data: (servers) => connectionsAsync.when(
          loading: () => _buildServerList(context, ref, servers, []),
          data: (connections) => _buildServerList(context, ref, servers, connections),
          error: (error, stack) => _buildServerList(context, ref, servers, []),
        ),
      ),
    );
  }
  
  Widget _buildServerList(
    BuildContext context,
    WidgetRef ref,
    List<MCPServerConfig> servers,
    List<String> connections,
  ) {
    if (servers.isEmpty) {
      return const Center(
        child: Text('No MCP servers configured'),
      );
    }
    
    return ListView.builder(
      itemCount: servers.length,
      itemBuilder: (context, index) {
        final server = servers[index];
        final isActive = connections.contains(server.id);
        
        return ListTile(
          leading: Icon(
            isActive ? Icons.check_circle : Icons.circle_outline,
            color: isActive ? Colors.green : Colors.grey,
          ),
          title: Text(server.name),
          subtitle: Text('${server.transportType.name} - ${server.url}'),
          trailing: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              IconButton(
                icon: const Icon(Icons.wifi),
                onPressed: () async {
                  final success = await ref.read(mcpServerListProvider.notifier).testServer(server.id);
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(success ? 'Connection successful' : 'Connection failed'),
                      backgroundColor: success ? Colors.green : Colors.red,
                    ),
                  );
                },
              ),
              IconButton(
                icon: const Icon(Icons.delete),
                onPressed: () async {
                  await ref.read(mcpServerListProvider.notifier).removeServer(server.id);
                },
              ),
            ],
          ),
        );
      },
    );
  }
  
  Future<void> _showAddServerDialog(BuildContext context, WidgetRef ref) async {
    final nameController = TextEditingController();
    final urlController = TextEditingController();
    final commandController = TextEditingController();
    
    final transportType = useState<MCPTransportType>(MCPTransportType.stdio);
    
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add MCP Server'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: nameController,
              decoration: const InputDecoration(
                labelText: 'Server Name',
                hintText: 'My MCP Server',
              ),
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<MCPTransportType>(
              initialValue: transportType.value,
              decoration: const InputDecoration(
                labelText: 'Transport Type',
              ),
              items: MCPTransportType.values.map((type) {
                return DropdownMenuItem(
                  value: type,
                  child: Text(type.name.toUpperCase()),
                );
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  transportType.value = value;
                }
              },
            ),
            const SizedBox(height: 16),
            if (transportType.value == MCPTransportType.stdio)
              TextField(
                controller: commandController,
                decoration: const InputDecoration(
                  labelText: 'Command',
                  hintText: 'npx @modelcontextprotocol/server-filesystem',
                ),
              )
            else
              TextField(
                controller: urlController,
                decoration: const InputDecoration(
                  labelText: 'Server URL',
                  hintText: 'http://localhost:8080',
                ),
              ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              final server = MCPServerConfig(
                id: 'server_${DateTime.now().millisecondsSinceEpoch}',
                name: nameController.text,
                transportType: transportType.value,
                url: urlController.text,
                command: commandController.text.isEmpty ? null : commandController.text,
                args: [],
                autoConnect: true,
              );
              
              await ref.read(mcpServerListProvider.notifier).addServer(server);
              Navigator.of(context).pop();
            },
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }
}